import os
import re

# =============================================================================
# Root Directory
# =============================================================================
root_directory = "../src/"

# =============================================================================
# Directory List
# =============================================================================
directory_list = [
    "./",
    "math/",
    "statistics/",
]

# =============================================================================
# File List
# =============================================================================
file_list = [
    "mod_math.f90",
    "mod_mean.f90",
    "mod_variance.f90",
]

# =============================================================================
# Exclude
# =============================================================================
exclude_list = []

# =============================================================================
# Wrapped Routines
# =============================================================================
wrapped_routines = [
    "divide",
    "add",
    "subtract",
    "mean",
    "variance",
]

# =============================================================================
# Regular Expressions
# =============================================================================
# General Patters
re_comment = re.compile(r"^\s*!")
re_program_start = re.compile(r"^\s*program\b", re.IGNORECASE)
re_module_start = re.compile(r"^\s*module\b (?!procedure)", re.IGNORECASE)
re_module_end = re.compile(r"^\s*end\s+module\b", re.IGNORECASE)
re_subroutine_start = re.compile(r"^\s*(recursive){0,1}\s*subroutine\b", re.IGNORECASE)
re_subroutine_end = re.compile(r"^\s*end\s+subroutine\b", re.IGNORECASE)
re_function_start = re.compile(r"^\s*function\b", re.IGNORECASE)
re_function_end = re.compile(r"^\s*end\s+function\b", re.IGNORECASE)
re_type_start = re.compile(r"^\s*type\s*(?!\(.*\))\b", re.IGNORECASE)
re_type_end = re.compile(r"^\s*end\s+type\b", re.IGNORECASE)

# Variable Definition Patters
re_real = re.compile(r"real(?=\(wp\))", re.IGNORECASE)

# Logical Patterns

# Casting Patters


def main():
    # Initialize Directory Structure
    initialize_directories()

    fortranFiles = []

    for filename in file_list:
        # Find File
        path_in, path_out = find_path(filename)

        # Read File
        lines = read_file(path_in)

        # Complexify File
        if filename not in exclude_list:
            lines = complexify(lines)

        # Write File
        write_file(path_out, lines)

        # Append to File Paths
        fortranFiles.append(path_out)

    # Write Build Instructions
    build_instructions(fortranFiles)


def initialize_directories():
    """
    Initialize directory structure for complex version.
    """
    for directory in directory_list:
        os.makedirs(directory, exist_ok=True)
    return


def find_path(filename):
    """
    Find the path of a file in the source directory provided a filename.

    Parameters
    ----------
    filename : string
        Name of file to be searched for.

    Returns
    -------
    path_in : string
        Relative path to file to be read in
    path_out: string
        Relative path to file to be written out
    """
    file_found = False

    for directory in directory_list:
        path_in = root_directory + directory + filename
        path_out = directory + filename
        if os.path.isfile(path_in):
            file_found = True
            break

    if not file_found:
        raise IOError(filename + " was not found in any defined directory search path.")

    return path_in, path_out


def read_file(path):
    """
    Read a file into memory to prepare it for complexifying.

    Parameters
    ----------
    path : string
        Path of file to be read into memory and imported
    """
    # Read File
    try:
        file = open(path, "r")
        lines = file.readlines()
        file.close()
    except IOError:
        raise IOError(path + " was not found or could not be imported.")

    return lines


def write_file(path, lines):
    """
    Write out the complexified file.

    Parameters
    ----------
    path : string
        Path of file to be written
    lines : list of string
        Lines of complexified code to be written
    """
    file = open(path, "w")
    file.writelines(lines)
    file.close()


def complexify(lines_in):
    """
    Carry out complexify process and change all file lines to be complex version. Takes
    file lines as input and outputs a complexified version of the lines.

    Parameters
    ----------
    lines_in : list of string
        Lines of original source code to be complexified

    Returns
    -------
    lines_out : list of string
        Lines of complexified code returned
    """
    iLine = 0
    lines_out = []

    # Write Header
    lines_out.append("! This file is automatically generated by complexify.py\n")

    # Fix Lines
    while iLine < len(lines_in):
        # Handle Comment
        if not re_comment.search(lines_in[iLine]) is None:
            lines_out.append(lines_in[iLine])
            iLine += 1

        # Handle Module Start
        elif not re_module_start.search(lines_in[iLine]) is None:
            iSearch = 0
            lines_module = []

            # Group All Subroutine Lines
            while re_module_end.search(lines_in[iLine + iSearch]) is None:
                lines_module.append(lines_in[iLine + iSearch])
                iSearch += 1
            lines_module.append(lines_in[iLine + iSearch])
            iSearch += 1

            # Fix Module
            lines_fixed = complexify_module(lines_module)
            for line in lines_fixed:
                lines_out.append(line)

            iLine += iSearch

        # Write Line Unchanged
        else:
            lines_out.append(lines_in[iLine])
            iLine += 1

    return lines_out


def complexify_program(lines_in):
    pass


def complexify_module(lines_in):
    """
    Complexify a module by separating its derived types, functions, and subroutines
    and passing them through a line complexification function.

    Parameters
    ----------
    lines_in : list of string
        List of strings source code for one module to be complexified

    Returns
    -------
    lines_out : list of string
        List of strings representing the output complexified module
    """
    N_line = len(lines_in)
    iLine = 0

    lines_out = []

    # Start Module
    lines_out.append(lines_in[0] + "use MOD_COMPLEXIFY\n")
    iLine += 1

    while iLine < N_line:
        # Handle Derived Type
        if not re_type_start.search(lines_in[iLine]) is None:
            iSearch = 0
            lines_type = []

            # Group All Subroutine Lines
            while re_type_end.search(lines_in[iLine + iSearch]) is None:
                lines_type.append(lines_in[iLine + iSearch])
                iSearch += 1
            lines_type.append(lines_in[iLine + iSearch])
            iSearch += 1

            # Fix Function
            lines_fixed = complexify_type(lines_type)
            for line in lines_fixed:
                lines_out.append(line)

            iLine += iSearch

        # Handle Function
        elif not re_function_start.search(lines_in[iLine]) is None:
            iSearch = 0
            lines_function = []

            # Group All Subroutine Lines
            while re_function_end.search(lines_in[iLine + iSearch]) is None:
                lines_function.append(lines_in[iLine + iSearch])
                iSearch += 1
            lines_function.append(lines_in[iLine + iSearch])
            iSearch += 1

            # Fix Function
            lines_fixed = complexify_function(lines_function)
            for line in lines_fixed:
                lines_out.append(line)

            iLine += iSearch

        # Handle Subroutine
        elif not re_subroutine_start.search(lines_in[iLine]) is None:
            iSearch = 0
            lines_subroutine = []

            # Group All Subroutine Lines
            while re_subroutine_end.search(lines_in[iLine + iSearch]) is None:
                lines_subroutine.append(lines_in[iLine + iSearch])
                iSearch += 1
            lines_subroutine.append(lines_in[iLine + iSearch])
            iSearch += 1

            # Fix Subroutine
            lines_fixed = complexify_subroutine(lines_subroutine)
            for line in lines_fixed:
                lines_out.append(line)

            iLine += iSearch

        # Write Line Unchanged
        else:
            lines_out.append(lines_in[iLine])
            iLine += 1

    return lines_out


def complexify_type(lines_in):
    """
    Complexify a derived type by passing its lines through all of the defined regular expressions
    and substituting where necessary.

    Parameters
    ----------
    lines_in : list of string
        List of strings source code for one derived type to be complexified

    Returns
    -------
    line_out : list of string
        List of strings representing the output complexified derived type
    """
    N_lines = len(lines_in)

    lines_out = []

    lines_out.append(lines_in[0])
    for iLine in range(1, N_lines - 1):
        line = complexify_line(lines_in[iLine])
        lines_out.append(line)
    lines_out.append(lines_in[N_lines - 1])

    return lines_out


def complexify_function(lines_in):
    """
    Complexify a function by passing its lines through all of the defined regular expressions
    and substituting where necessary.

    Parameters
    ----------
    lines_in : list of string
        List of strings source code for one function to be complexified

    Returns
    -------
    line_out : list of string
        List of strings representing the output complexified function
    """
    N_lines = len(lines_in)

    lines_out = []

    lines_out.append(lines_in[0])
    for iLine in range(1, N_lines - 1):
        line = complexify_line(lines_in[iLine])
        lines_out.append(line)
    lines_out.append(lines_in[N_lines - 1])
    return lines_out


def complexify_subroutine(lines_in):
    """
    Complexify a subroutine by passing its lines through all of the defined regular expressions
    and substituting where necessary.

    Parameters
    ----------
    lines_in : list of string
        List of strings source code for one subrotuine to be complexified

    Returns
    -------
    line_out : list of string
        List of strings representing the output complexified subroutine
    """
    N_lines = len(lines_in)

    lines_out = []

    lines_out.append(lines_in[0])
    for iLine in range(1, N_lines - 1):
        line = complexify_line(lines_in[iLine])
        lines_out.append(line)
    lines_out.append(lines_in[N_lines - 1])
    return lines_out


def complexify_line(line_in):
    """
    Complexify a single line by passing it through all the defined regular expressions and
    substituting where necessary.

    Parameters
    ----------
    line_in : string
        String of source code to be complexified

    Returns
    -------
    line_out : string
        String of complexified code to be returned
    """
    line_out = line_in

    if not re_real.search(line_out) is None:
        line_out = re.sub(re_real, "complex", line_out)
    return line_out


def build_instructions(fortranFiles):
    """
    Write build instructions for `directory list`, `file_list`, and `subroutines` wrapping. Three files are
    generated, the `directoryList` file, the `fileList` file, and the `wrapping` file.

    Parameters
    ----------
    fortranFiles : list of string
        Relative paths to complex source code fortran files.
    """
    # Write Directory List File
    write_directoryList()

    # Write File List File
    write_fileList(fortranFiles)

    # Write Wrapping File
    write_wrapping()


def write_directoryList():
    """
    Write `directoryList` file with specified complex source code directories.
    """
    # Open File
    file = open("build/directoryList", "w")

    # Write Directories
    file.write("dirs := ")
    for directory in directory_list:
        file.write("\\\n" + directory)

    # Close File
    file.close()


def write_fileList(fortranFiles):
    """
    Write 'fileList` file with specified complex source code files.

    Parameters
    ----------
    fortranFiles : list of strings
        Relative paths to complex source code fortran files.
    """
    # Open File
    file = open("build/fileList", "w")

    # Write File
    file.write("fortranFiles=")
    file.write("\\\n mod_complexify.f90")
    for filename in fortranFiles:
        file.write("\\\n" + filename)

    # Close File
    file.close()


def write_wrapping():
    """
    Write `wrapping` file with specified complex source code wrapping names and subroutines.
    """
    # Open File
    file = open("build/wrapping", "w")

    # Write Wrapping Files
    file.write("wrap_files=")
    f90 = re.compile(r"\.f90$", re.IGNORECASE)

    for filename in file_list:
        fpp_filename = re.sub(f90, ".fpp", filename)
        file.write("\\\n" + fpp_filename)

    file.write("\n")

    # Write Wrapping Subroutines
    file.write("wrap_subroutines=")
    for routine in wrapped_routines:
        file.write("\\\n" + routine)

    # Close File
    file.close()


if __name__ == "__main__":
    main()
